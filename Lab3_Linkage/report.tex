\documentclass[a4paper]{report}
\pagestyle{headings}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{color}
\lstset{language=bash}
\lstset{numbers=right}
\lstset{breaklines}
\title{Lab Report for Object-oriented Programming course \newline
 Lab 3: Linkage}
\author{Wang, Chen \\ 16307110064 \\ School of Software\\ Fudan University}
\date{\today}
\bibliographystyle{plain}
\begin{document}
\maketitle

\tableofcontents

\chapter{Understanding Internal and External Linkage}
\section{Requirements}
In this part, we are going to analyze the running result of the following short program and will try to make some subtle modifications whose change will result in the complete change of the result.
The codes are shown below.

\subsection{header.h}
\begin{lstlisting}[language=C++]
#ifndef LAB3_HEAER_H
#define LAB3_HEAER_H

static int variable = 0;
extern int variable2;
#endif //LAB3_HEAER_H

\end{lstlisting}


\subsection{file1.h}
\begin{lstlisting}[language=C++]
#ifndef LAB3_FILE1_H
#define LAB3_FILE1_H
void function1();

#endif //LAB3_FILE1_H

\end{lstlisting}

\subsection{file2.h}
\begin{lstlisting}[language=C++]
#ifndef LAB3_FILE2_H
#define LAB3_FILE2_H
void function2();

#endif //LAB3_FILE2_H

\end{lstlisting}


\subsection{file1.cpp}
\begin{lstlisting}[language=C++]
#include "header.h"

void function1() {
    variable = 1;
    variable2 = 1;
}
\end{lstlisting}

\subsection{file2.cpp}
\begin{lstlisting}[language=C++]
#include "header.h"
void function2() {
    variable = 2;
    variable2 = 2;

}
\end{lstlisting}

\subsection{main.cpp}
\begin{lstlisting}[language=C++]
#include <iostream>
#include "header.h"
#include "file1.h"
#include "file2.h"
int variable2;

int main() {
    function1();
    function2();

    std::cout << variable << std::endl;
    std::cout << variable2 << std::endl;
    return 0;
}
\end{lstlisting}



\section{Execution result}
The result of the execution is shown in the Figure \ref{1} below.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{result1.PNG}
  \caption{Execute Results}\label{1}
\end{figure}
\section{Analysis for the result of static variable}
From the C++ language standards, we can know that the \emph{static} keyword has different implications and effects in two different occasions. In this project, the keyword appears before the definition of the global variable outside from any methods. In this case, the \emph{static} keyword has the effect that the variable is only accessible in the specified file, i.e. having a \emph{file scope}.
\par
More specifically, in this project there are three \textbf{cpp} files in this project, each of them including the \emph{header.h} header file where a static variable is declared. In this case, each of the three files has a version of the static variable \emph{variable}. Therefore, the methods \emph{function1} and \emph{function2} will have no effect to the variable \emph{variable} in the \emph{main} method. Hence, the printing result is unchanged.

\section{Analysis for the result of global variable}
As to another part of this lab, the printing result of \emph{variable2}, is a typical example of a global variable. Nevertheless, one slightly point making the analysis more complex is that the \emph{external} keyword is used to make the global variable declared and defined at different places. 
\par
More specifically, in this project, the variable \emph{variable2} is declared in \emph{header.h} with an \emph{external} keyword, indicating that this variable will be defined somewhere else in this project. Then in the file \emph{main.cpp} this variable is defined. Therefore, this is a typical example of global variable and all the functions are modifying the same version of the variable. Therefore, the \emph{main} function will print the result after being changed in the other functions.

\section{Task 1.2: Duplicate variable definition}
The result of the change is shown in the Figure \ref{2} below, indicating an compiling error.


\begin{figure}
  \centering
  \includegraphics[scale=0.5]{Onetow.PNG}
  \caption{Execute Results of Task 1.2}\label{2}
\end{figure}


In this example, we have two places both defining the variable \emph{variable2}. Therefore, the compiler will report a duplicate definition error.
\section{Task 1.3: External declaration without definition}

The result of the change is shown in the Figure \ref{3} below, indicating an compiling error.


\begin{figure}
  \centering
  \includegraphics[scale=0.5]{Onethree.PNG}
  \caption{Execute Results of Task 1.3}\label{3}
\end{figure}


As per have stated above, an \emph{extern} keyword indicates that this variable is defined somewhere else in this file, hence it will cause a compiling error if no definition is made through out the project file.


\chapter{Understanding Name Space}
\section{Task 2.2 Duplicate variable naming in separate name spaces}
In this task, we are going to use the name space mechanism, create two variables with the same name but different values and print them.
\par
Here in my implementation, I declared two name spaces called \textbf{a} and \textbf{b} separately and then a variable named \textbf{a} in each name space but different value. Then in the \emph{main} method, these two variables are printed separately, we can see the result that they have different values printed. The result is shown in the Figure \ref{4} below.


\begin{figure}
  \centering
  \includegraphics[scale=0.5]{TwoOne.PNG}
  \caption{Execute Results of Task 2.1}\label{4}
\end{figure}

\section{Task 2.2 Extended namespace}
In this task, I will need to duplicately declare the namespace of the same name in two files. The space of the first file defines ``ab=1; cd=2'', and the space of the second file is defined, ``ab=3;bc=4'' Finally, print the value in the namespace in the main function.
\par
Here in my implementation, I declared a name space called \textbf{a} in two separate files and then assigned different values to the variables as stated. Then in the \emph{main} method, these three variables are printed separately, we can see the result that this project cannot be compiled due to duplicate variable definition in the same name space. The result is shown in the Figure \ref{5} below.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{TwoTwo.PNG}
  \caption{Execute Results of Task 2.2}\label{5}
\end{figure}

\chapter{Compare with Typescript Name Space}

\section{Modules in TypeScript}
\emph{\textbf{A note about terminology}: It’s important to note that in TypeScript 1.5, the nomenclature has changed. ``Internal modules'' are now ``namespaces''. ``External modules'' are now simply ``modules'', as to align with ECMAScript 2015\footnote{Ecma International. (2019, May 5). ECMAScript 2015 Language Specification – ECMA-262 6th Edition. In \emph{Ecma International}. Retrieved 08:23, May 11, 2019, from \url{http://www.ecma-international.org/ecma-262/6.0/}}'s terminology, (namely that \textcolor[rgb]{0.749,0.255,0.29}{module X \{ } is equivalent to the now-preferred \textcolor[rgb]{0.749,0.255,0.29}{namespace X \{} ).}
\subsection{Introduction}
Starting with ECMAScript 2015, JavaScript has a concept of modules. TypeScript shares this concept.
\par
Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the \emph{export} forms. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the \emph{import} forms.
\par
Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.
Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known modules loaders used in JavaScript are the CommonJS module loader for Node.js and require.js for Web applications.
\par
In TypeScript, just as in ECMAScript 2015, any file containing a top-level \emph{import} or \emph{export} is considered a module. Conversely, a file without any top-level \emph{import} or \emph{export} declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).
\subsection{Export}
\subsubsection{Exporting a declaration}
Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the \emph{export} keyword.
\subsubsection{Export statements}
Export statements are handy when exports need to be renamed for consumers.
\subsubsection{Re-exports}
Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.
\par
Optionally, a module can wrap one or more modules and combine all their exports using \emph{export * from ``module''} syntax.
\subsection{Import}
Importing is just about as easy as exporting from a module. Importing an exported declaration is done through using one of the \emph{import} forms below:

\begin{enumerate}
\item Import a single export from a module
\item Import the entire module into a single variable, and use it to access the module exports
\item Import a module for side-effects only
\end{enumerate}

Though not recommended practice, some modules set up some global state that can be used by other modules. These modules may not have any exports, or the consumer is not interested in any of their exports.
\subsection{Default exports}
Each module can optionally export a \emph{default} export. Default exports are marked with the keyword \emph{default}; and there can only be one \emph{default} export per module. \emph{default} exports are imported using a different import form.
\emph{default} exports are really handy. For instance, a library like jQuery might have a default export of \emph{jQuery} or \$, which we’d probably also import under the name \$ or jQuery.
\par
Classes and function declarations can be authored directly as default exports. Default export class and function declaration names are optional.
\subsection{\emph{export =} and \emph{import = require()}}
Both CommonJS and AMD generally have the concept of an \emph{exports} object which contains all exports from a module.
\par
They also support replacing the \emph{exports} object with a custom single object. Default exports are meant to act as a replacement for this behavior; however, the two are incompatible. TypeScript supports \emph{export =} to model the traditional CommonJS and AMD workflow.
\par
The \emph{export =} syntax specifies a single object that is exported from the module. This can be a class, interface, namespace, function, or enum.
\par
When exporting a module using \emph{export =}, TypeScript-specific \emph{import module = require("module")} must be used to import the module.

\subsection{Code Generation for Modules}
Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (\textbf{CommonJS}), require.js (\textbf{AMD}), \textbf{UMD}, \textbf{SystemJS}, or \textbf{ECMAScript 2015 native modules} (ES6) module-loading systems. For more information on what the \emph{define}, \emph{require} and \emph{register} calls in the generated code do, consult the documentation for each module loader.

\subsection{Optional Module Loading and Other Advanced Loading Scenarios}
In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.
\par
The compiler detects whether each module is used in the emitted JavaScript. If a module identifier is only ever used as part of a type annotations and never as an expression, then no \emph{require} call is emitted for that module. This elision of unused references is a good performance optimization, and also allows for optional loading of those modules.
The core idea of the pattern is that the \emph{import id = require("...")} statement gives us access to the types exposed by the module. The module loader is invoked (through \emph{require}) dynamically, as shown in the if blocks below. This leverages the reference-elision optimization so that the module is only loaded when needed. For this pattern to work, it’s important that the symbol defined via an \emph{import} is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).
To maintain type safety, we can use the \emph{typeof} keyword. The \emph{typeof} keyword, when used in a type position, produces the type of a value, in this case the type of the module.

\section{Name space in TypeScript}
\subsection{Introduction}
In this subsection I will try to outline the various ways to organize the code using namespaces (previously “internal modules”) in TypeScript. As per alluded in previous section's note about terminology, ``internal modules'' are now referred to as “namespaces”. Additionally, anywhere the module keyword was used when declaring an internal module, the namespace keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.
\subsection{Namespacing}
As we have more and more methods of the same or of similiar functions, we're going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, we can wrap up our objects into a namespace.
\par
If we want the interfaces and classes in the namespace to be visible outside the namespace, we can preface them with export. Conversely, the implementation details can be left unexported and will not be visible to code outside the namespace. 
\subsection{Splitting Across Files}
As our application grows, we’ll want to split the code across multiple files to make it easier to maintain.
\subsubsection{Multi-file namespaces}
We can split our namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we’ll add reference tags to tell the compiler about the relationships between the files.
\subsection{Aliases}
Another way that you can simplify working with namespaces is to use \emph{import q = x.y.z} to create shorter names for commonly-used objects. Not to be confused with the \emph{import x = require("name")} syntax used to load modules, this syntax simply creates an alias for the specified symbol. We can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.
\par
Notice that we don’t use the \emph{require} keyword; instead we assign directly from the qualified name of the symbol we’re importing. This is similar to using \emph{var}, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, \emph{import} is a distinct reference from the original symbol, so changes to an aliased \emph{var} will not be reflected in the original variable.

\section{Difference and relation between modules and name spaces in TypeScript}
\subsection{Introduction}
In this section, I will try to  clarify the difference on both concept and usage of modules and namespace in Typescript.
\subsection{Using Namespaces}
Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. They can span multiple files, and can be concatenated using \emph{--outFile}. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as \emph{<script>} tags in your HTML page.
\par
Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.
\subsection{Using Modules}
Just like namespaces, modules can contain both code and declarations. The main difference is that modules \textbf{declare} their dependencies.
\par
Modules also have a dependency on a module loader (such as CommonJs/Require.js). For a small JS application this might not be optimal, but for larger applications, the cost comes with long term modularity and maintainability benefits. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.
\par
It is also worth noting that, for Node.js applications, modules are the default and the recommended approach to structure your code.
\par
Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.
\section{Internal Linkage in C++}

\section{External Linkage in C++}

\section{Name space in C++}

\section{Difference and relation between TypeScript module and C++ internal linkage}

\section{Difference and relation between TypeScript module and C++ external linkage}

\section{Difference and relation between TypeScript module and C++ name space}

\section{Difference and relation between TypeScript name space and C++ internal linkage}

\section{Difference and relation between TypeScript name space and C++ external linkage}

\section{Difference and relation between TypeScript name space and C++ name space}

\begin{thebibliography}{A}

\bibitem{1}
Wikipedia contributors. (2019, May 5). TypeScript. In \emph{Wikipedia, The Free Encyclopedia}. Retrieved 08:23, May 11, 2019, from \url{https://en.wikipedia.org/w/index.php?title=TypeScript&oldid=895568490}

\bibitem{2}
Wikipedia contributors. (2019, May 9). JavaScript. In \emph{Wikipedia, The Free Encyclopedia}. Retrieved 08:24, May 11, 2019, from \url{https://en.wikipedia.org/w/index.php?title=JavaScript&oldid=896215789}

\bibitem{3}
Wikipedia contributors. (2019, April 24). C++. In \emph{Wikipedia, The Free Encyclopedia}. Retrieved 08:25, May 11, 2019, from \url{https://en.wikipedia.org/w/index.php?title=C%2B%2B&oldid=893975016}

\bibitem{4}
Wikipedia contributors. (2019, February 27). Object-oriented programming. In \emph{Wikipedia, The Free Encyclopedia}. Retrieved 10:22, March 23, 2019, from \url{https://en.wikipedia.org/w/index.php?title=Object-oriented_programming&oldid=885274966}

\bibitem{5}
Wikipedia contributors. (2019, March 18). Namespace. In \emph{Wikipedia, The Free Encyclopedia}. Retrieved 08:27, May 11, 2019, from \url{https://en.wikipedia.org/w/index.php?title=Namespace&oldid=888324103}
\end{thebibliography}
\end{document} 